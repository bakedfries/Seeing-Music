# -*- coding: utf-8 -*-
"""statistical-analysis-of-music.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/bakedfries/967c83d4fc0cd9920b186dbb1a9cfe5e/statistical-analysis-of-music.ipynb
"""

import pandas as pd
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import numpy as np
from wordcloud import WordCloud
from PIL import Image

"""# Statistical Analysis of Music: TikTok Trending Music

TikTok songs charting in January
"""

tiktokJan = pd.read_csv('/content/drive/MyDrive/Statistical Analysis of Music/TikTok songs _ January 2024.csv')

"""Analyzing some basic stats ont he jan charts"""

pd.set_option('display.max_columns', None)
tiktokJan.head(5)

tiktokJan.info()

tiktokJan.nunique()

"""Some observations:

So in the TikTok Chart, out of the 222 total songs, there were 4 songs that were repeats.

Also interesting observation that there were only 186 unique artists. Meaning, 36 enteries were from repeating artists that charted in January. But something to note is that, the 'artists' here could indicate all collaborating artists as one artist for a particular song. We'll further break this down and look at the true number of independent artists charting, not taking collaborations into regard.
"""

tiktokJan.isnull().sum() #Shows how many null values are present

tiktokJan.describe().transpose()

"""#Genre Analysis

It's looking like for the most part, the data doesn't have any null values for our main categories. Genre, in music, is highly subjective and songs tend to bend genres a lot of the times. Creative endeavors can't be labelled sometimes under a specified label. Take that data!!
"""

tiktokJan['Genres'].value_counts()

#creating a list that stores all genres

xemp = [] #temporary helper list where we will split al our genres

for i in tiktokJan.Genres:
  xemp.append(i)

cleanedList = [x for x in xemp if str(x) != 'nan'] #cleaning up the null values

genreList = [] #splittling up each genre from the "list of list" format to individual items of the list
for i in cleanedList:
  genreList.append(i.split(",")[0])

genreDataFrame = pd.DataFrame(genreList, columns=['Genres']) #finally, creating the list into a dataframe for ease of analysis

genreDataFrame.value_counts()

"""There are 76 total genres!

Looking at the most popular genres that repeat more than one time:
"""

numGenresGreaterThanTwo = genreDataFrame.groupby('Genres').filter(lambda x: len(x) > 1 ).value_counts()
num = len(numGenresGreaterThanTwo)

genreDataFrame.groupby('Genres').filter(lambda x: len(x) > 1 ).value_counts().plot(kind= "barh", title="Genres repeating more than once", colormap= "Set2") #omg?? this actually worked wtf??????! okay for future self, we're filtering those genres that appear more than once, so minimum 2 times, wowowowow

"""Looking at the "one hit wonders" of the list (pun intended lol?)"""

from collections import Counter

ones = genreDataFrame.groupby('Genres').filter(lambda x: len(x) == 1 ) #Looking at those genres that only appeared once in the list
#create a dictionary here

#convert list to string and generate
wmask = np.array(Image.open("/content/drive/MyDrive/Statistical Analysis of Music/piano.png"))

text = ",".join(review for review in ones.Genres.astype(str))

wordcloud = WordCloud(background_color="white", width=800, height=400).generate(text)

#text

# Create a word cloud image

wc = WordCloud(background_color="black", max_words=150, mask=wmask,
               contour_width=3, contour_color='steelblue', width=800, height=400)

# Generate a wordcloud

wc.generate(text)

# store to file

#wc.to_file("/content/drive/MyDrive/Statistical Analysis of Music/singer.JPG")

# show
plt.imshow(wc)
plt.axis("off")
plt.show()
plt.savefig('wordcloud.png', facecolor='k', bbox_inches='tight')

"""# Artist Analysis"""

tiktokJan[tiktokJan.duplicated('Artist', keep=False)].sort_values('Artist')
rep = tiktokJan[['Artist', 'Song', 'Popularity']].copy()

rep

rep.Artist.str.split(pat=",", expand=True) #separating artists from our dataframe to a new dataframe

"""Checking Artists, Collaborations Included"""

repeatingArtist = rep[rep.duplicated(['Artist'], keep=False)].sort_values('Artist') #looking at those artist that repeat

colors = ['gold', 'mediumturquoise', 'darkorange', 'lightgreen', 'lime', 'green']

fig = go.Figure(data=[go.Pie(labels= repeatingArtist['Artist'],values= repeatingArtist['Song'].value_counts())])
fig.update_traces(title_text = "Artists with the most hits in the TikTok Global 200", hoverinfo='label+percent', textinfo='value', textfont_size=20,
                  marker=dict(colors=colors, line=dict(color='#000000', width=2)
                  ))
fig.show()

"""Looking at the artists individually,, beyond collaborations."""

newdf = repeatingArtist.Artist.str.split(pat=",", expand=True) #separating artists from our dataframe to a new dataframe

newList = newdf[0]. tolist() + newdf[1].tolist() + newdf[2].tolist() #creating a new list based on the split dataframe so that this list can store all the split values from each column

artistList = pd.DataFrame(newList) #converting this new sliced list to a dataframe for ease of analysis again

artistList = artistList.drop(artistList[artistList[0] == 'The Creator'].index) #fixing Tyler, The Creator because his name was unfortunately spliced :((

artistList.replace("Tyler", "Tyler, The Creator") #yay, we've fixed that now :))
artistList = artistList.replace(to_replace='None', value=np.nan).dropna() #cleaning up the dataframe and dropping all null values!!

artistList #anddd drumroll

artistList.value_counts().plot(kind ='barh')

"""It's extremely clear that RIELL, BRAN, Besomage adn Hypermorph are the most popular artists. These artists have charted multiple times throughout the chart with 5 or more songs. These songs were either stand-alone singles or collaborations between artists (or a combination of the same 4 artists!)

#Relationships between various features: What makes these songs popular on TikTok?

##Correlation Heatmap
"""

correlation_matrix = tiktokJan.corr(method='pearson')
plt.figure(figsize=(12, 8))  # Adjust the size as needed
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap='coolwarm', linewidths=.5)
plt.title('Correlation Heatmap')
plt.show()

"""##Loudness and Energy Levels"""

correlation_energy_loudness = tiktokJan[['Energy', 'Loud']].corr().iloc[0, 1]
print(f'Pearson Correlation between Energy and Loudness: {correlation_energy_loudness}')
plt.figure(figsize=(10, 6))
sns.scatterplot(data=tiktokJan, x='Loud', y='Energy', color='blue', edgecolor='black')
plt.title('Energy vs. Loudness')
plt.xlabel('Loudness')
plt.ylabel('Energy')
plt.grid(True)
plt.show()

"""A clear trend in the plot

##Danceability and Happy Levels
"""

correlation_dance_happy = tiktokJan[['Happy', 'Dance']].corr().iloc[0, 1]
print(f'Pearson Correlation between Happy and Dance: {correlation_energy_loudness}')
plt.figure(figsize=(10, 6))
sns.scatterplot(data=tiktokJan, x='Happy', y='Dance', color='blue', edgecolor='black')
plt.title('Happy vs Dance')
plt.xlabel('Happy')
plt.ylabel('Dance')
plt.grid(True)
plt.show()

"""
##BPM and Popularity"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

#BPM and Popularity
# Calculate the correlation
correlation = tiktokJan[['BPM', 'Popularity']].corr().iloc[0, 1]

# Visualize the relationship
plt.figure(figsize=(10, 6))
sns.scatterplot(data=tiktokJan, x='BPM', y='Popularity', s=100, color='blue', edgecolor='black')
plt.title('Relationship between BPM and Popularity')
plt.xlabel('BPM')
plt.ylabel('Popularity')
plt.grid(True)
plt.show()

print(f'Correlation coefficient between BPM and Popularity: {correlation}')

# Step 3: Analyze Genre and Popularity
tiktokJan['Primary Genre'] = tiktokJan['Genres'].apply(lambda x: x.split(',')[0] if pd.notnull(x) else 'Unknown')

# Group by 'Primary Genre' and calculate average popularity
genre_popularity = tiktokJan.groupby('Primary Genre')['Popularity'].mean().sort_values(ascending=False)

# Visualize the average popularity by genre
plt.figure(figsize=(12, 6))
genre_popularity.plot(kind='bar', color='skyblue', edgecolor='black')
plt.title('Average Popularity by Primary Genre')
plt.xlabel('Primary Genre')
plt.ylabel('Average Popularity')
plt.xticks(rotation=90)
plt.grid(axis='y', linestyle='--')
plt.show()

"""## BPM and Its Effect on Danceability and Energy"""

# Calculate correlation coefficients
correlation_bpm_dance = tiktokJan[['BPM', 'Dance']].corr().iloc[0, 1]
correlation_bpm_energy = tiktokJan[['BPM', 'Energy']].corr().iloc[0, 1]

print(f'Correlation between BPM and Danceability: {correlation_bpm_dance}')
print(f'Correlation between BPM and Energy: {correlation_bpm_energy}')

# Scatter plot for BPM and Danceability
plt.figure(figsize=(10, 6))
sns.scatterplot(data=tiktokJan, x='BPM', y='Dance', color='turquoise', edgecolor='black')
plt.title('BPM vs. Danceability')
plt.xlabel('BPM')
plt.ylabel('Danceability')
plt.grid(True)
plt.show()

# Scatter plot for BPM and Energy
plt.figure(figsize=(10, 6))
sns.scatterplot(data=tiktokJan, x='BPM', y='Energy', color='coral', edgecolor='black')
plt.title('BPM vs. Energy')
plt.xlabel('BPM')
plt.ylabel('Energy')
plt.grid(True)
plt.show()

"""##Impact of Release Dates"""

# Convert release dates to datetime format
tiktokJan['Album Date'] = pd.to_datetime(tiktokJan['Album Date'],errors='coerce')

# Extract useful date parts
tiktokJan['Month'] = tiktokJan['Album Date'].dt.month
tiktokJan['DayOfWeek'] = tiktokJan['Album Date'].dt.dayofweek  # Monday=0, Sunday=6
tiktokJan['Season'] = tiktokJan['Album Date'].dt.month % 12 // 3 + 1  # 1: Winter, 2: Spring, 3: Summer, 4: Fall

# Example: Analyzing by Month
avg_by_month = tiktokJan.groupby('Month')[['Popularity', 'Dance', 'Energy']].mean()

# Example: Analyzing by Season
avg_by_season = tiktokJan.groupby('Season')[['Popularity', 'Dance', 'Energy']].mean()

import matplotlib.pyplot as plt

# Plotting average metrics by month
avg_by_month.plot(kind='bar', figsize=(14, 7))
plt.title('Average Metrics by Month')
plt.xlabel('Month')
plt.ylabel('Average Value')
plt.xticks(ticks=range(12), labels=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], rotation=0)
plt.legend(title='Metrics')
plt.show()

# Plotting average metrics by season
avg_by_season.plot(kind='bar', figsize=(10, 5))
plt.title('Average Metrics by Season')
plt.xlabel('Season')
plt.ylabel('Average Value')
plt.xticks(ticks=range(4), labels=['Winter', 'Spring', 'Summer', 'Fall'], rotation=0)
plt.legend(title='Metrics')
plt.show()

"""##Key and Camelot Relationship

Distribution of Songs by Key and Camelot Code: This can help understand which keys and Camelot codes are most common in the dataset.


Relationship between Camelot Code and Song Metrics: Analyze if certain Camelot codes are associated with higher popularity, danceability, energy, etc.


Transition Analysis: Explore potential transitions between songs based on their Camelot codes to suggest harmonically compatible mixes.
"""

import pandas as pd
import matplotlib.pyplot as plt

# Distribution by Key
key_distribution = tiktokJan['Key'].value_counts().sort_index()

# Distribution by Camelot Code
camelot_distribution = tiktokJan['Camelot'].value_counts().sort_index()

# Plotting
plt.figure(figsize=(14, 7))
plt.subplot(1, 2, 1)
key_distribution.plot(kind='bar', title='Distribution by Musical Key')
plt.xlabel('Musical Key')
plt.ylabel('Number of Songs')

plt.subplot(1, 2, 2)
camelot_distribution.plot(kind='bar', title='Distribution by Camelot Code')
plt.xlabel('Camelot Code')
plt.ylabel('Number of Songs')

plt.tight_layout()
plt.show()

"""Popularity by Key"""

import pandas as pd
import matplotlib.pyplot as plt

# Group by 'Key' and calculate average popularity
avg_popularity_by_key = tiktokJan.groupby('Key')['Popularity'].mean().sort_values(ascending=False)

# Plotting
plt.figure(figsize=(12, 6))
avg_popularity_by_key.plot(kind='bar', color='skyblue', edgecolor='black')
plt.title('Average Popularity by Key')
plt.xlabel('Musical Key')
plt.ylabel('Average Popularity')
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--')
plt.show()

# Grouping by Camelot Code and calculating average metrics
avg_metrics_by_camelot = tiktokJan.groupby('Camelot')[['Popularity', 'Dance', 'Energy']].mean()

# Plotting
avg_metrics_by_camelot.plot(kind='bar', figsize=(14, 7), title='Average Metrics by Camelot Code')
plt.xlabel('Camelot Code')
plt.ylabel('Average Metric Value')
plt.legend(title='Metrics')
plt.show()

"""DJs use this feature to mix songs with compatilble camelots. This function helps determine what camelots are useful when trying to mix them seamlessly using transitions between songs."""

def find_compatible_camelot_codes(code):
    number, letter = int(code[:-1]), code[-1]
    compatible_codes = [f"{(number - 2) % 12 + 1}{letter}", f"{number}{letter}", f"{(number % 12) + 1}{letter}"]
    if letter == 'A':
        compatible_codes.append(f"{number}B")
    else:
        compatible_codes.append(f"{number}A")
    return compatible_codes

# Example: Find compatible codes for 5A
compatible_codes = find_compatible_camelot_codes('5A')
print("Compatible Camelot Codes for 5A:", compatible_codes)

"""# Analysis of Spotify USA 50 Charts"""

USATop50 = pd.read_csv('/content/drive/MyDrive/Statistical Analysis of Music/Top 50 - USA.csv')
USATop50.head(3)

"""Let's look at the Popularity of the songs. Spotify determines this 'Popularity' index by calculating the following metrics:

1. Total number of streams of a song
2. How recently that song has been played on Spotify
3. The frequency that the track has been played
"""

USATop50.columns

"""##Popularity of Songs"""

USATop50.sort_values('Popularity')
USATop50.sort_values(by = "Popularity", ascending=True).plot(x="Song", y="Popularity",
        kind="barh", figsize=(10, 10))

plt.xlim(75, 100)
plt.xticks(range(75, 101))
plt.title("Popularity of the USA Top 50 songs")

"""##Release Dates: Old releases vs New releases

Looking at the release dates of these songs
"""

USATop50["Date"] = pd.to_datetime(USATop50['Album Date']) # convert column to datetime
USATop50['year_month'] = USATop50["Date"].map(lambda dt: dt.strftime('%Y-%m'))

songReleaseDf = USATop50.groupby('year_month').size().to_frame("Song").reset_index()

songReleaseDf.plot(kind='barh', x='year_month', y='Song')
plt.title("Release Dates of Songs Charting USA Top 50 on January 10th 2024")

"""September 2023 releases seem to be the most popular even 3+ months after their release. October releases outperformed the August releases (5 and 3 songs respectively). The oldest song to chart is from 2002, followed by a 2008 release."""

USATop50['year_month']
USATop50['year'] = USATop50["Date"].map(lambda dt: dt.strftime('%Y'))
USATop50['year'] = pd.to_numeric(USATop50['year'])


USATop50.plot(x="Song", y= "year",
        kind="barh", figsize=(10, 10))

plt.xlim(2000, 2024)
plt.xticks(range(2000, 2025))
plt.xticks(rotation=90)

"""##Correlations of features

"""

correlation_matrix = USATop50.corr(method='pearson')
plt.figure(figsize=(12, 8))  # Adjust the size as needed
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap='coolwarm', linewidths=.5)
plt.title('Correlation Heatmap for Spotify Chart Features')
plt.show()

"""## Energy vs Loudness Levels"""

correlation_energy_loudness = USATop50[['Energy', 'Loud']].corr().iloc[0, 1]
print(f'Pearson Correlation between Energy and Loudness: {correlation_energy_loudness}')
plt.figure(figsize=(10, 6))
sns.scatterplot(data=USATop50, x='Loud', y='Energy', color='blue', edgecolor='black')
plt.title('Energy vs. Loudness')
plt.xlabel('Loudness')
plt.ylabel('Energy')
plt.grid(True)
plt.show()

"""There is an obvious strong correlation between the Loudness and Energy levels between songs. The upward trend proves this. Thus, we can conclude saying that songs that are high energy and are loud are popular features and make an impact on if the songs chart or not."""

correlation_energy_loudness = USATop50[['Acoustic', 'Loud']].corr().iloc[0, 1]
print(f'Pearson Correlation between Acoustic and Loudness: {correlation_energy_loudness}')
plt.figure(figsize=(10, 6))
sns.scatterplot(data=USATop50, x='Loud', y='Acoustic', color='blue', edgecolor='black')
plt.title('Acoustic vs. Loudness')
plt.xlabel('Loudness')
plt.ylabel('Acoustic')
plt.grid(True)
plt.show()

"""There is a strong negative correlation between acoustic songs the loudness factor. Acoustic songs tend to be less loud. Let's look at the 5 most "acoustic" song that trended."""

USATop50[['Song','Loud','Acoustic']].sort_values(by = 'Acoustic', ascending = False).head(10)

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

#BPM and Popularity
# Calculate the correlation
correlation = USATop50[['BPM', 'Popularity']].corr().iloc[0, 1]

# Visualize the relationship
plt.figure(figsize=(10, 6))
sns.scatterplot(data=USATop50, x='BPM', y='Popularity', s=100, color='blue', edgecolor='black')
plt.title('Relationship between BPM and Popularity')
plt.xlabel('BPM')
plt.ylabel('Popularity')
plt.grid(True)
plt.show()

print(f'Correlation coefficient between BPM and Popularity: {correlation}')

# Step 3: Analyze Genre and Popularity
USATop50['Primary Genre'] = USATop50['Genres'].apply(lambda x: x.split(',')[0] if pd.notnull(x) else 'Unknown')

# Group by 'Primary Genre' and calculate average popularity
genre_popularity = USATop50.groupby('Primary Genre')['Popularity'].mean().sort_values(ascending=False)

# Visualize the average popularity by genre
plt.figure(figsize=(12, 6))
genre_popularity.plot(kind='bar', color='skyblue', edgecolor='black')
plt.title('Average Popularity by Primary Genre for Spotify Charts')
plt.xlabel('Primary Genre')
plt.ylabel('Average Popularity')
plt.xticks(rotation=90)
plt.grid(axis='y', linestyle='--')
plt.show()

# Grouping by Camelot Code and calculating average metrics
avg_metrics_by_camelot = USATop50.groupby('Camelot')[['Popularity', 'Dance', 'Energy']].mean()

# Plotting
avg_metrics_by_camelot.plot(kind='bar', figsize=(14, 7), title='Average Metrics by Camelot Code')
plt.xlabel('Camelot Code')
plt.ylabel('Average Metric Value')
plt.legend(title='Metrics')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Group by 'Key' and calculate average popularity
avg_popularity_by_key = USATop50.groupby('Key')['Popularity'].mean().sort_values(ascending=False)

# Plotting
plt.figure(figsize=(12, 6))
avg_popularity_by_key.plot(kind='bar', color='skyblue', edgecolor='black')
plt.title('Average Popularity by Key')
plt.xlabel('Musical Key')
plt.ylabel('Average Popularity')
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Distribution by Key
key_distribution = USATop50['Key'].value_counts().sort_index()

# Distribution by Camelot Code
camelot_distribution = USATop50['Camelot'].value_counts().sort_index()

# Plotting
plt.figure(figsize=(14, 7))
plt.subplot(1, 2, 1)
key_distribution.plot(kind='bar', title='Distribution by Musical Key')
plt.xlabel('Musical Key')
plt.ylabel('Number of Songs')

plt.subplot(1, 2, 2)
camelot_distribution.plot(kind='bar', title='Distribution by Camelot Code')
plt.xlabel('Camelot Code')
plt.ylabel('Number of Songs')

plt.tight_layout()
plt.show()

# Convert release dates to datetime format
USATop50['Album Date'] = pd.to_datetime(USATop50['Album Date'],errors='coerce')

# Extract useful date parts
USATop50['Month'] = USATop50['Album Date'].dt.month
USATop50['DayOfWeek'] = USATop50['Album Date'].dt.dayofweek  # Monday=0, Sunday=6
USATop50['Season'] = USATop50['Album Date'].dt.month % 12 // 3 + 1  # 1: Winter, 2: Spring, 3: Summer, 4: Fall

# Example: Analyzing by Month
avg_by_month = USATop50.groupby('Month')[['Popularity', 'Dance', 'Energy']].mean()

# Example: Analyzing by Season
avg_by_season = USATop50.groupby('Season')[['Popularity', 'Dance', 'Energy']].mean()

import matplotlib.pyplot as plt

# Plotting average metrics by month
avg_by_month.plot(kind='bar', figsize=(14, 7))
plt.title('Average Metrics by Month')
plt.xlabel('Month')
plt.ylabel('Average Value')
plt.xticks(ticks=range(12), labels=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], rotation=0)
plt.legend(title='Metrics')
plt.show()

# Plotting average metrics by season
avg_by_season.plot(kind='bar', figsize=(10, 5))
plt.title('Average Metrics by Season')
plt.xlabel('Season')
plt.ylabel('Average Value')
plt.xticks(ticks=range(4), labels=['Winter', 'Spring', 'Summer', 'Fall'], rotation=0)
plt.legend(title='Metrics')
plt.show()

"""# Visual Interpretation of Music

I will lbe using a nifty little python  library called librosa that helps analyse musical files.
Note: Top50Charts features names are mixed up. Song preview is actually the image and the other way around
"""

import librosa
import numpy as np
from urllib.request import urlopen
import IPython.display as ipd
import librosa.display

"""We're playing the audio file, testing our text file"""

testfile = "/content/drive/MyDrive/Statistical Analysis of Music/test.mp3.mp3"
ipd.Audio(testfile)

lovingOnMe, sr = librosa.load(testfile) #sr = sample rate, mono = true/false, we usually work with mono audio

print("Sample size = ", lovingOnMe.size)
print("Sample rate = ", sr)
print("Sample rate * lenght of the track aka 30 seconds = ",sr * 30)

""" The sample rate for the clip is 22,050 Hz. The size of the audio signal is 655,164. Our 30 second clip can be broken down to 22050 Hz and 655164 units. Imagine we're taking 22050 snapshots of the sound wave every second for 30 seconds to create a digital representation of the audio. The size refers to the number of individual measurements or samples in the audio, and each of these individual pieces represents an amplitude of sound at that specific moment in time."""

print("Audio time series = ", lovingOnMe)

sample_duration = 1/sr
print(f"Duration of 1 sample is {sample_duration:.5f} seconds")

print("total duration of the song = ", len(lovingOnMe) * sample_duration)

"""Visualizing the waveforms"""

plt.figure(figsize =(15,10))
plt.subplot(1,1,1)
librosa.display.waveshow(lovingOnMe)

"""Percussive and Harmonic Components in the song can be separated and analysed. The percussions in the sample song seems to be persistent throughout the song. The harmonics remain pretty similar throughout the song except between the 6-15 second mark where in the song, the instrumentation is pulled back and the segment features an emphasis on spoken lyrics in teh audio above. It seems that the loudness/impact of the percussions are also noticable pulled back so that the listeners can listen better."""

y_harm, y_perc = librosa.effects.hpss(lovingOnMe)
librosa.display.waveshow(y_harm, sr=sr, alpha=0.5, label='Harmonic')
librosa.display.waveshow(y_perc, sr=sr, color='r', alpha=0.3, label='Percussive')
plt.legend()

"""Looking at these separately,"""

librosa.display.waveshow(y_perc, sr=sr, color='r', alpha=0.3, label='Percussive')
plt.legend()

librosa.display.waveshow(y_harm, sr=sr, alpha=0.5, label='Harmonic')
plt.legend()

y = lovingOnMe

D = librosa.stft(lovingOnMe)  # STFT of y
#D
S_db = librosa.amplitude_to_db(np.abs(D), ref=np.max)
plt.figure()
librosa.display.specshow(S_db)
plt.colorbar()

fig, ax = plt.subplots()
img = librosa.display.specshow(S_db, x_axis='time', y_axis='log', ax=ax)
ax.set(title='Using a logarithmic frequency axis')
fig.colorbar(img, ax=ax, format="%+2.f dB")

C = librosa.cqt(y=y, sr=sr)
C_db = librosa.amplitude_to_db(np.abs(C), ref=np.max)

fig, ax = plt.subplots()
librosa.display.specshow(C_db, y_axis='cqt_note', x_axis='time', ax=ax)
ax.set(title='Pitch axis decoration')

chroma = librosa.feature.chroma_cqt(y=y, sr=sr)
fig, ax = plt.subplots()
img = librosa.display.specshow(chroma, y_axis='chroma', x_axis='time', ax=ax)
ax.set(title='Chromagram demonstration')
fig.colorbar(img, ax=ax)

fig, ax = plt.subplots()
img = librosa.display.specshow(chroma, y_axis='chroma', x_axis='time',
                               key='D:major', ax=ax)
ax.set(title='Chromagram explicitly in D:major')
fig.colorbar(img, ax=ax)

pd.Series(y_trimmed[1000:3000]).plot(figsize=(10,10), title = "Zoomed in from 1000 to 3000")

pd.Series(y_trimmed[1000:2000]).plot(figsize=(10,10), title = "Zoomed in from 1000 to 2000")

pd.Series(y_trimmed[1000:1500]).plot(figsize=(10,10), title = "Zoomed in from 1000 to 1500")

pd.Series(y_trimmed[1000:1100]).plot(figsize=(10,10), title = "Zoomed in from 1000 to 1100")

"""# Keys and Such
##Determining the colors
"""

USATop50[['Song', 'Key']].head()

"""There have been many attempts to visualize emotions motivated by music through colors. Because this is heavily inspired by my own mild- synesthesia
, I have found a resource online that makes sense to me. This part of the project is very subjective. Trying to "see" music is something I have tried to make sense and it was one of the many factors that motivated me to complete this project. In this part of the project, I wanted to find a way to translate waves to colors and represent them visually. For this, I came up with the following gameplan:

1. Assign each feature a color based on what each feature may "look" like
2. Give each feature's color a weight, based on how prominently that feature affects the overall vibe of the song.

For example, between "Energy", "Loud" and "Acoustic", the overall feel of the song is more influenced by "Energy" than "Acoustic". Hence, the prominence of the "Energy" color will carry more weight.

These "weights" determine how intense the colors will appear. Those songs with a higher values for "Energy" and "Loud", will appear more bright mixes of warm red and yellow and those that may score lower on these features might appear more pastel. The ultimate color of these songs will be determined after applying these assigned weights to the data provided by Spotify on these features adn normalizing it on a scale of 1 to 10. The score on this scale will determine how bright or light each assigned feature's color will appear and influence the final picture. Thus, after getting the score for each color, we will mix the RGB values for each color. This way, an end color is determined for each song based on the features, their intensities and the mixing of those colors.

3. Step 2 gives us the color of the vibe of the song it best represents based on the data provided to us. I wanted to incorporate the color of the Key of the song as well, as there have been a lot of research on the influence of the key and the overall feel adn mood of the song. This will also be used in the visual representation of the songs we analyze. This step will present us the color of the key of the song we are analyzign.

4. Now, based on the information we have calculated from above, we can proceed with creating a visual element that encorporates the color of the mood of the song from step 2 and the color of the key from step 3.

Because it made sense thematically, I picked the representation be a circular plot of the spectrogram of the songs we analyze. Here, the waves/spectrogram of the song will be the color we calculated from Step 2. The background of the spectrogram will be the color of the key that we have calculated from step 3. To acheive this, I coded a program in P5.js that will build a spectrogram of the song we play in real time, with the option to pause and save the picture at the end. I called this "Seeing Music"

'This can be accessed here:

"https://editor.p5js.org/adahal-thunder/full/ecB9NAzM-

Thus, tldr; This motebook will provide the two color components needed for the spectrogram. After manually inputting those colors in the link above will present the visual component of this project.

#Testing with AAABEST

After a conversation with Prof Forsberg, I asked him what his favourite album was. This album by AAA called AAABEST was the response (great album rec btw prof) I got. In honor of Prof Forsberg being the best Data Science advisor ever, I picked his fav album to test out the visuals.
"""

AB = pd.read_csv('/content/drive/MyDrive/Statistical Analysis of Music/#AAABEST.csv')
AB.Key

ABFeatures = AB[['Song', 'Energy','Happy', 'Dance', 'Loud',  'Live', 'Acoustic','Instrumental', 'Speech','Key' ]]
ABFeatures

import numpy as np

# Create a new column 'Sad' with 0 as default values
ABFeatures['Sad'] = 0

# Use .loc to find rows where 'Happy' is less than 50, then move those values to 'Sad'
ABFeatures.loc[ABFeatures['Happy'] < 50, 'Sad'] = ABFeatures.loc[ABFeatures['Happy'] < 50, 'Happy']

# Set 'Happy' to 0 where 'Happy' was less than 50
ABFeatures.loc[ABFeatures['Happy'] < 50, 'Happy'] = 0

# Now, ABFeatures will have the 'Sad' column with values moved from 'Happy' where 'Happy' was less than 50

ABFeatures
AAABEST = ABFeatures.copy()
AAABEST = AAABEST[['Song', 'Energy','Happy', 'Sad', 'Dance', 'Loud',  'Live', 'Acoustic','Instrumental', 'Speech', 'Key']]

AAABEST

"""Normalizing and Scaling from 1 to 10 for each of the features. Here we define the "intensities" of the color."""

import pandas as pd
import numpy as np

# Normalize 'Loud' from -60 to 0 dB to 0 to 100 scale
AAABEST['Loud'] = AAABEST['Loud'].apply(lambda x: ((x - (-60)) / (0 - (-60))) * 100)

# Define weights for each feature
weights = {
    'Energy': 3,
    'Happy': 2.5,
    'Sad': 2.5,
    'Dance': 1,
    'Loud': 1.5,  # Already normalized to 0-100 scale
    'Live': 0.6,
    'Acoustic': 0.4,
    'Instrumental': 0.7,
    'Speech': 0.3
}

# Multiply each feature by its weight and normalize to a 0-10 scale
for feature, weight in weights.items():
    max_value = AAABEST[feature].max() * weight  # Maximum possible weighted value for normalization
    AAABEST[feature] = AAABEST[feature].apply(lambda x: ((x * weight) / max_value) * 10)

# Combine all features into a single array column 'Intensities'
AAABEST['Intensities'] = AAABEST.apply(lambda row: [row[feature] for feature in weights.keys()], axis=1)

for i in AAABEST.Intensities:
  print(i)

"""##Final Color

"""

#testing the color mixing

from PIL import ImageColor

def mix_colors(intensities, colors):
    rgb_colors = [ImageColor.getcolor(color, "RGB") for color in colors]
    sum_weighted_colors = [0, 0, 0]
    total_intensity = sum(intensities)
    if total_intensity == 0:
        return '#000000'
    for intensity, rgb in zip(intensities, rgb_colors):
        weight = intensity / total_intensity
        sum_weighted_colors = [sum_weighted_colors[i] + weight * rgb[i] for i in range(3)]
    mixed_rgb = tuple(min(max(0, int(color)), 255) for color in sum_weighted_colors)
    return '#{:02x}{:02x}{:02x}'.format(*mixed_rgb)

def mix_colors_for_all_rows(df, intensities_col, colors):
    mood_colors = []
    for intensities in df[intensities_col]:
        mixed_color = mix_colors(intensities, colors)
        mood_colors.append(mixed_color)
    return mood_colors

# Define the colors for each feature
colors = ["#ff9900", "#ffff00", "#391690", "#ff00a9", "#ff0000", "#fff2cc", "#8a8691", "#6d9eeb", "#000000"]

# Apply color mixing for all rows
AAABEST['MoodColor'] = mix_colors_for_all_rows(AAABEST, 'Intensities', colors)

"""0     #c52c45
1     #f07f55
2     #e56a4f
3     #c94d2f
4     #c05270
5     #a22538
6     #d42d45
7     #cf2f46
8     #db5963
9     #df5a62
10    #fe7c4e
11    #fe803c
12    #fe7f4d
13    #c72d46
14    #fe7c4d

Now, we want to map the color of the keys to their base colors. This is taken from Mr. Mars's Musical Color Wheel
"""

key_color_mapping = {
    'C Major': 'Cyan',
    'G Major': 'Chrysolite',
    'D Major': 'Bright Green',
    'A Major': 'Chartreuse',
    'E Major': 'Yellow',
    'B Major': 'Turmeric',
    'F#/G♭ Major': 'Red',
    'C#/D♭ Major': 'Pink',
    'G#/A♭ Major': 'Magenta',
    'D#/E♭ Major': 'Violet',
    'A#/B♭ Major': 'Corn Flower',
    'F Major': 'Azure',
    'A Minor': 'Pthalo Green',
    'E Minor': 'Brunswick Green',
    'B Minor': 'Zucchini',
    'F# Minor': 'Oak Leaf',
    'C# Minor': 'Olive Drab',
    'G# Minor': 'Milk Chocolate',
    'E♭/D# Minor': 'Maroon',
    'A#/B♭ Minor': 'Elderberry',
    'F Minor': 'Purple',
    'C Minor': 'Spectral Violet',
    'G Minor': 'Ultramarine',
    'D Minor': 'Prussian Blue'
}

import pandas as pd

AAABEST['KeyColor'] = AAABEST['Key'].map(key_color_mapping)
AAABEST[['Song','KeyColor', 'Key']]

"""Now changing hex colors to RBG values"""

# Function to convert hex to RGB
def hex_to_rgb(hex_color):
    hex_color = hex_color.lstrip('#')  # Remove '#' if it exists
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

# Apply the function to each row in the 'hex_color' column
AAABEST['MoodColorinRBG'] = AAABEST['MoodColor'].apply(hex_to_rgb)

AAABEST[['Song','MoodColor','MoodColorinRBG', 'Key', 'KeyColor']]

"""Voilà! Here's all the information we need to create our eye!
To make things easier, Here's the rbg value for each of the key colors:

Chartreuse (187, 255, 0)


Azure (0,170, 255)

Turmeric (255, 191, 0)

Zucchini (0,79, 0)

Cyan (0, 255, 255)

Elderberry (112, 0, 74)

Spectral Violet (76, 0, 115)

Magenta (255, 0, 255)

Pthalo Green (0, 74, 74)

Chrysolite (0, 255, 170)

#Trying it with another album, Glow part2. by The Microphones
"""

glow = pd.read_csv('/content/drive/MyDrive/Statistical Analysis of Music/The Glow, Pt. 2.csv')

glowFeatures = glow[['Song', 'Energy','Happy', 'Dance', 'Loud',  'Live', 'Acoustic','Instrumental', 'Speech','Key' ]]
glowFeatures

import numpy as np

# Create a new column 'Sad' with 0 as default values
glowFeatures['Sad'] = 0

# Use .loc to find rows where 'Happy' is less than 50, then move those values to 'Sad'
glowFeatures.loc[glowFeatures['Happy'] < 50, 'Sad'] = glowFeatures.loc[glowFeatures['Happy'] < 50, 'Happy']

# Set 'Happy' to 0 where 'Happy' was less than 50
glowFeatures.loc[glowFeatures['Happy'] < 50, 'Happy'] = 0

# Now, glowFeatures will have the 'Sad' column with values moved from 'Happy' where 'Happy' was less than 50

key_color_mapping = {
    'C Major': 'Cyan',
    'G Major': 'Chrysolite',
    'D Major': 'Bright Green',
    'A Major': 'Chartreuse',
    'E Major': 'Yellow',
    'B Major': 'Turmeric',
    'F#/G♭ Major': 'Red',
    'C#/D♭ Major': 'Pink',
    'G#/A♭ Major': 'Magenta',
    'D#/E♭ Major': 'Violet',
    'A#/B♭ Major': 'Corn Flower',
    'F Major': 'Azure',
    'A Minor': 'Pthalo Green',
    'E Minor': 'Brunswick Green',
    'B Minor': 'Zucchini',
    'F# Minor': 'Oak Leaf',
    'C# Minor': 'Olive Drab',
    'G#/A♭ Minor': 'Milk Chocolate',
    'E♭/D# Minor': 'Maroon',
    'A#/B♭ Minor': 'Elderberry',
    'F Minor': 'Purple',
    'C Minor': 'Spectral Violet',
    'G Minor': 'Ultramarine',
    'D Minor': 'Prussian Blue'
}

glow.Key

import pandas as pd

glowFeatures['KeyColor'] = glowFeatures['Key'].map(key_color_mapping)
glowFeatures[['Song','KeyColor', 'Key']]

# Function to convert hex to RGB
def hex_to_rgb(hex_color):
    hex_color = hex_color.lstrip('#')  # Remove '#' if it exists
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

# Apply the function to each row in the 'hex_color' column
glowFeatures['MoodColorinRBG'] = glowFeatures['MoodColor'].apply(hex_to_rgb)